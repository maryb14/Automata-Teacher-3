<?xml version="1.0" encoding="utf-8"?>
<resources>
  <string name="Hello">Hello World, Click Me!</string>
  <string name="ApplicationName">Automata Teacher</string>
  <string name="Topic1Section1">
    "Generally speaking, an automaton is a device which performs an action automatically. According to the Meriam-Webster dictionary it is \' a machine or control mechanism designed to follow automatically a predetermined sequence of operations or respond to encoded instructions\'. For instance, an ATM is an automaton, a vending machine is also an automaton and your computer is an automaton too, but indeed a very complex one.\n However, in this application we want to present automata from a theoretical point of view. That means that through abstraction and generalization, computer scientists have reached a way of modeling and encoding an automaton. Later on, an entire branch of computer science evolved around the study of these machines and their properties have been mesmerizing scientists for some years now. \n So, theoretically speaking, an automaton is a device that receives a sequence of inputs and accepts or rejects it. To reach such a decision, the machine goes through a finite number of states. There are two ways of imagining an automaton. \n First, you can picture a box that can read from a tape, which has written on it a sequence of input symbols. It also must have a way of expressing its rejection or acceptance, possibly through a little light bulb. While this picture is rather close to the real world and can be regarded as familiar, it does not explain what goes on inside the automaton. \n The second method is more explicit. You can imagine the automaton as a graph which will represent what can happen in the box from the 1st representation. \n As a graph, it must have nodes and edges. The nodes are represented by the states of the automaton and the edges are labeled with a condition for the transition to happen and what happens during the respective transition. \n As an example, a state in an ATM is when the debit card has been introduced in the machine and the condition for a transition to a subsequent state can be the inputting of the correct PIN."
  </string>
  <string name="Topic1Section2">
    "The graph in the figure is also an automaton. As you can see, there are some components of such a machine that ought to be defined in more detail. \n 1 – 7 are the stated and they form together the finite collection of states of this automaton. This collection is often denoted by means of the letter Q. Here Q = {1, 2, 3, 4, 5, 6, 7}. Out of these, there are several states with special properties. As marked, 1 is the beginning state, which will be usually named q0. The encircled one, 4, is the acceptance state and 5, 6, 7 are rejection states. One should also note that there can be more acceptance states, which will form the set F, F⊆Q. \n Another extremely important element is formed by the two symbols this automaton seems to accept: 0, 1. Indeed, they form the collection Σ = {0, 1} which is called the alphabet of the automaton. \n To summarize, an automaton is a mathematical object defined by a quintuple, (Q,Σ,δ,q0,F), each symbol with the meaning explained above."
  </string>
  <string name="Topic2Section1">
    "One interesting observation that can be made when returning to the automaton from the first lesson is through which sequences can the machine get in the 4th state, the accepting one? Can we see a pattern?"
  </string>
  <string name="Topic2Section2">
    "To begin with, we can observe that the first symbol of the sequence has to be a 0 and the second symbol a 1. Assuming we won’t go back to the second state, the next symbol will be a 1 and if we don’t introduce anything more, we get 011 to be an accepted sequence. Were we to go back to the second state once, we assess that 01011 is also an accepted sequence. If we go twice through the loop formed by the states 2 and 3, we get 0101011 as an accepted sequence. Thus, it is seems sensible to conclude that any sequence of the form (01)*1 is accepted by this automaton (* means a positive number of repetitions of the patterns in parentheses). All the sequences (an infinite number of them actually) form together the accepted language of the automaton. \n To put the languages of the automata in perspective, a few more definitions have to be included. We begin by observing that the finite automaton described up to now has two main limitations: it receives inputs, but it can’t write anything and it moves the tape in a unidirectional way. Through eliminating these limitations, we can achieve more powerful machines. \n Firstly, we can alter the automaton in the following way: we add a second tape, on which the automaton can write and we keep the unidirectional reading restriction. As far as the second tape is concerned, the automaton has access to the last written element. It knows its value and has two choices: to delete the current element and move back one step or move forward one step and write another element. Thus, this tape is analogous to a stack, obeying the LIFO principle. This machine is called a pushdown automaton. \n To make the automaton even more powerful, we can enable it to write on the very same tape it reads from, but also to move the tape either way (left or right). As a result, we obtain actually two types of machines: linear-bounded automata (in this case, the tape is finite) and Turing machines (the tape at the automaton’s disposal is infinite). \n Now we can link these four types of automata to the notion of language. Each one accepts a type of language, as follows:"
  </string>
  <string name="Topic2Section3">
    "One should note that the four languages grow in generality from left to right, each type being included in the one immediately to its right."
  </string>
  <string name="Topic3Section1">
    "There are four components included in a generative grammar: \n N, a set(alphabet) of nonterminal symbols \n T, a set(alphabet) of terminal symbols \n n, the initial symbol, a distinguished element from N \n P, a set of production rules (X => Y, where X and Y are sequences of symbols (words)). \n The set of all words generated by such a grammar is called the language generated by G, the grammar. \n For instance, let us consider the following grammar: \n N = {a, b, c} \n n=a; \n T= {A, B, C} \n P = { (a=>Bc), (c=>bA), (b=>C)} \n As a result we obtain the following sequences of transformations: \n a=>Bc=>BbA=>BCA. \n These four words and the symbols {b, c} form the language of the grammar. \n What is the most interesting aspect about these grammars is their link with automata. We have previously seen that there are four types of languages recognized by the four types of machines. Well, each one can be obtained from a generative grammar which obeys certain rules. \n For regular languages, the productions are allowed to have two forms: a=>bA or a=>A, where a and b are nonterminal symbols and A is a terminal one. \n As far as context-free languages are concerned, production rules follow the pattern a=>A, where a is a nonterminal symbol and A is a word belonging to the language (so it can consist of both terminal and nonterminal symbols). \n Next, the context-sensitive languages are defined by productions of the form AaB=>ACB, where A, B, C are strings belonging to the language and a is a nonterminal symbol. \n Now we can see why the latter is called context-sensitive language and the previous one context-free. \n Last but not least, the grammars that have no restrictions in their production rules define recursively enumerable languages, recognized by Turing machines."
  </string>
  <string name="Topic4Section1">
    "Since 1961, when 3 American computer scientist proved it, we have a theorem for determining whether a language is regular or not. \n The pumping lemma says the following: \n If a language L was to be regular, then there is a constant l such that for every word, W, in L of length > l we can find three words X, Y, Z that have the properties: \n 1.	W=XYZ \n 2.	Length of Y>=1 \n 3.	X(Y)kZ also belong to L, where k=1, 2, 3, … \n The lemma can easily be proved, even if we won’t use too many mathematical notations. For a language to be regular it must be recognized by a finite automaton. We will consider that the automaton has a total of n states and we will give the constant l from the lemma the value n+1. As every character present in a inputted string means going to a new state, it means that in order to accept the a word of length l = n+1, the automaton must have gone through n+1 states. By applying the pigeonhole principle, we can securely claim that the automaton has been in one state (qr) twice. Thus, there is a sequence of states that form a loop – from qr to the next occurrence of qr. The characters corresponding to this sequence are the one in Y. It is now obvious that any string of the form (XY)kZ will be accepted by the automaton if XYZ is accepted, as the repetition of Y in the strings means only new reiterations of the loop we mentioned earlier.\n \n Let us now prove that L={(a)n(b)n} is not a regular language ((a)n means n repetitions of a). \n Firstly, we assume that L is regular. Thus, we can find a value which satisfies the lemma: let’s call it v. We can now consider every word whose length is bigger than v and we shall find the X, Y, Z which satisfy the conditions of the lemma. To find a contradiction (which is ultimately our purpose) we analyze W=(a)v(b)v, whose length is obviously bigger than v. We try to find the string Y. \n There are 3 possibilities: \n 1.	Y contains only a’s and its length is y. This can’t be true because we would obtain the string W’=(a)v+y(b)v, but as v+y is not equal to v, then W’ will not be accepted by the automaton. Y can’t contain only a’s. \n 2.	Y contains only b’s. The reasoning is analogous to the one for the first possibility. Y can’t contain only b’s. \n 3.	Y contains a sequence of i a’s and j b’s (Y=(a)i(b)j). Through repetition, we obtain W’=(a)v-i(a)i(b)j(a)i(b)j(b)v-j, which will definitely be rejected by the automaton, as it doesn’t follow the requested pattern. This possibility isn’t correct either. \n To conclude, L={(a)n(b)n} is not a regular language. \n What should also be kept in mind is that the lemma doesn’t prove that a language is regular. It proves that a language isn’t. So, you can pick a language and check if the lemma applies. If it doesn’t, the language is not regular. If it does, the language might be regular. \n As a little homework, try to design a pushdown automaton which will accept only the language L={(a)n(b)n}."
  </string>

  <string name = "Topic5Section1">
    "Up to now, we have considered that if we have a state q1 and the next input read by the automaton is the symbol s1 the next state is uniquely determined. Well, that is not always the case. And when the next state is not uniquely determined the name of automaton receives also the adjective non-deterministic. For instance, in the following image we can see a NFA (non-deterministic finite automaton)."
  </string>
  <string name = "Topic5Section2"> 
    "One question that arises after understanding these two types of automata is whether the non-deterministic automata are more powerful or general than the deterministic ones. The answer depends on which type of automata (finite, pushdown, linear-bounded or Turing machines) we are speaking about and it is a very detailed one is most cases. For linear-bounded automata we don’t even know it. However, as far as the other three categories are concerned, computer scientists have found that NFA and DFA(deterministic finite automata) are equivalent as are the two types of Turing machines. However, in the case of pushdown automata, the opposite situation occurs: deterministic automata are less powerful than the non-deterministic ones. \n Here, I want to highlight how we can derive a deterministic finite automaton from a non-deterministic one, thereby proving their equivalence. \n To perform such a transformation, the state of the deterministic automaton will be represented by subsets of the set of states of the initial NFA. \n For instance, let’s imagine the following situation. In a NFA we start from a state labeled q0 and if we receive a symbol labeled s1, we can go to either q1 or q2. This transitions can be portrayed in a DFA by a start state p1(equivalent to q0) that, when receiving s1, leads to a state p2 (equivalent to the subset of states {q1, q2} from the NFA). You may wonder now - when receiving a symbol s2, where does p2 it go? To where the state q1 went when receiving a s2 or where the state q2 went under the same circumstances? The answer is: both. If q1 receiving s2 provokes a transition to q3 and q4, while the q2 receiving s2 leads to q4 and q5, the state p2, when receiving a s2, will lead to {q3, q4}U{q4, q5}, which is equal to {q3, q4, q5}. Thus, the state p2 and the input symbol s2 cause a transition to a state p3, equivalent to the subset {q3, q4, q5}. It can also be easily demonstrated that a transition in the DFA is an accepting state if and only if the subset it represents contains an accepting state from the initial NFA. \n To make it clearer, please consider the following image."
  </string>
  <string name = "Topic5Section3">
    "We have a NFA, as state 1, when receiving the symbol 1, leads to either state 2 or state 1. \n Now, we are going to transform this NFA into a DFA. Firstly, we add 3 states, corresponding to the 3 subsets of the set {state 1, state 2}."
  </string>
  <string name = "Topic5Section4">
    "Then we start from state 1: receiving an one, state 1 might lead to state 1 or 2, so we add an edge between state 1 and the subset with two elements."
  </string>
  <string name = "Topic5Section5">
    "Receiving a zero, state1 only returns to itself. We add the according edge."
  </string>
  <string name = "Topic5Section6">
    "Now we analyze the states we have reached so far, apart from the start state whose case has just been solve. That is, we analyze the state equivalent to the two-element subset. If this subset receives a 0, it causes only one possible transition: to state 1. We add the proper edge."
  </string>
  <string name = "Topic5Section7">
    "If it receives a 1, the states which can be reached from the initial NFA are states 1 and 2 so we add an edge returning to the subset itself."
  </string>
  <string name = "Topic5Section8">
    "Thus, we just obtained a DFA. \n If you want to brush up your drawing skills and want to have some fun, try to transform the NFA from the first image in this lesson into a DFA."
  </string>
</resources>

